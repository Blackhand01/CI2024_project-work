import heapq
import random
import numpy as np
from core.evaluator import Evaluator
from core.tree import Node, random_variable, random_constant

class HeapBasedOptimizer:
    """
    Heap-Based Genetic Programming Optimizer.
    
    This algorithm organizes candidate solutions in a heap.
    Initially, a min-heap is built based on the fitness (where lower values
    indicate better solutions). In each iteration, the best candidate is
    extracted; a set of mutated candidates is generated by applying a simple mutation
    operation. If any mutated candidate shows an improvement in fitness, it is reinserted into the heap.
    
    Parameters:
      - population: list of candidate solutions (GP trees).
      - x, y: input and output data for evaluation.
      - bloat_penalty: penalty for tree complexity.
      - max_iterations: maximum number of optimization iterations.
      - neighbor_count: number of mutated candidates to generate for each extracted candidate.
    """
    def __init__(self, population, x, y, bloat_penalty, max_iterations=50, neighbor_count=5):
        self.x = x
        self.y = y
        self.bloat_penalty = bloat_penalty
        self.max_iterations = max_iterations
        self.neighbor_count = neighbor_count
        self.evaluator = Evaluator()
        self.heap = []
        self.counter = 0  # Counter to ensure uniqueness of tuples in the heap
        
        for candidate in population:
            fitness = self.evaluator.fitness_function(candidate, self.x, self.y, self.bloat_penalty)
            self.counter += 1
            heapq.heappush(self.heap, (fitness, self.counter, candidate))
    
    def optimize(self):
        """
        Executes the heap-based optimization for a maximum number of iterations.
        Returns the best candidate (GP tree) and its fitness.
        """
        iteration = 0
        while iteration < self.max_iterations and self.heap:
            iteration += 1
            # Extract the best candidate from the heap
            best_fitness, _, best_candidate = heapq.heappop(self.heap)
            improvement_found = False
            
            # Generate a set of mutated candidates
            for _ in range(self.neighbor_count):
                mutated_candidate = self._generate_neighbor(best_candidate)
                mutated_fitness = self.evaluator.fitness_function(mutated_candidate, self.x, self.y, self.bloat_penalty)
                
                # If the mutated candidate improves fitness, insert it into the heap
                if mutated_fitness < best_fitness:
                    self.counter += 1
                    heapq.heappush(self.heap, (mutated_fitness, self.counter, mutated_candidate))
                    improvement_found = True
            
            # If no mutated candidate improved the fitness, reinsert the original candidate to maintain diversity
            if not improvement_found:
                self.counter += 1
                heapq.heappush(self.heap, (best_fitness, self.counter, best_candidate))
        
        # At the end, return the candidate with the best fitness
        best_overall = heapq.heappop(self.heap)
        return best_overall[2], best_overall[0]
    
    def _generate_neighbor(self, candidate):
        """
        Generates a mutated candidate by applying a simple mutation operation.
        """
        mutated_candidate = candidate.copy_tree()
        node, _ = Node.get_random_node(mutated_candidate)
        
        # If the node is internal, change the operator while preserving the same arity
        if node.op is not None:
            from core.safe_math import ALL_OPERATORS
            valid_operators = [
                op.name for op in ALL_OPERATORS.values()
                if op.arity == ALL_OPERATORS[node.op].arity
            ]
            node.op = random.choice(valid_operators)
        else:
            # If it is a leaf node, modify its value (constant or variable)
            if node.is_variable():
                node.value = random_constant()
            else:
                node.value = random_variable(self.x.shape[1])
                
        return mutated_candidate
